<!--



📚 Aula Explicada Passo a Passo: Navbar + Menu Hambúrguer em React + TailwindCSS
🎯 O que vamos aprender
1. Como criar uma barra de navegação (navbar) em React.
2. O que é o menu hambúrguer e como ele funciona em telas pequenas.
3. Como usar o estado (useState) para abrir e fechar a sidebar.
4. Como o TailwindCSS nos ajuda com classes prontas para layout e responsividade.



1️⃣ Estrutura da Navbar
Pensa assim:
. A navbar é um retângulo fixo no topo da página, com:
  . O logo ou nome à esquerda.
  . Os links no meio ou à direita.
  . O botão hambúrguer que aparece só no celular.

👉 Em React, cada pedaço da tela é um componente. Então criamos um componente chamado Navbar.

import React, { useState } from "react"

export default function Navbar() {
  const [open, setOpen] = useState(false) // estado para controlar se o menu está aberto ou fechado

  return (
    <nav className="fixed w-full flex items-center justify-between px-6 py-4 bg-black/80 text-white z-40">
      <h1 className="text-2xl font-bold">
        <span className="text-sky-300">Mikael</span> Rocha
      </h1>
    </nav>
  )
}

 
🔎 Aqui temos:
. useState(false) → começa fechado (false).
. nav → a barra de navegação.
. fixed w-full → fixa no topo e ocupa a largura da tela inteira.
. px-6 py-4 → espaçamento interno.
. bg-black/80 → fundo preto com transparência.

 


2️⃣ Links da navbar:

Agora colocamos os links de navegação.
Queremos que eles só apareçam em telas maiores (computador).
No Tailwind, fazemos isso com hidden md:flex.

<ul className="hidden md:flex gap-8 text-lg">
  <li><a href="#sobre">Sobre</a></li>
  <li><a href="#projeto">Projetos</a></li>
  <li><a href="#skills">Skills</a></li>
  <li><a href="#contato">Contato</a></li>
</ul>


🔎 Aqui:
. hidden → por padrão fica invisível.
. md:flex → a partir do tamanho md (tablet para cima) vira flex e aparece.
. gap-8 → espaçamento entre os itens.

3️⃣ Botão Hambúrguer

Esse é o botão que aparece somente no celular.
Ele abre o menu lateral quando clicamos.

<button
  className="md:hidden text-3xl"
  onClick={() => setOpen(true)}
>
  <i className="bx bx-menu"></i>
</button>


🔎 Aqui:
. md:hidden → o botão só aparece em telas menores que md.
. text-3xl → aumenta o tamanho do ícone.
. onClick={() => setOpen(true)} → quando clicamos, mudamos o estado open para true.
. i className="bx bx-menu" → ícone do hambúrguer (as 3 listrinhas).




4️⃣ Sidebar (menu lateral no mobile):

Agora o truque principal: só queremos mostrar a sidebar se open === true.
No React, usamos {open && (...)}.

{open && (
  <div className="fixed top-0 left-0 w-2/3 h-full bg-black/90 text-white flex flex-col p-6 z-50">
    {/* Botão fechar */}
    <button
      className="self-end text-3xl mb-6"
      onClick={() => setOpen(false)}
    >
      <i className="bx bx-x"></i>
    </button>

    {/* Links mobile */}
    <ul className="flex flex-col gap-6 text-lg">
      <li><a href="#sobre" onClick={() => setOpen(false)}>Sobre</a></li>
      <li><a href="#projeto" onClick={() => setOpen(false)}>Projetos</a></li>
      <li><a href="#skills" onClick={() => setOpen(false)}>Skills</a></li>
      <li><a href="#contato" onClick={() => setOpen(false)}>Contato</a></li>
    </ul>
  </div>
)}


🔎 Detalhes importantes:
. {open && (...)} → significa “se open for true, renderiza isso”.
. fixed top-0 left-0 → fixa a sidebar no canto superior esquerdo.
. w-2/3 h-full → ocupa 2/3 da tela em largura e 100% da altura.
. bg-black/90 → fundo preto semi-transparente.
. z-50 → garante que aparece por cima de tudo.
. setOpen(false) → fecha o menu quando clicamos no X ou em um link.



5️⃣ Como tudo funciona junto (fluxo):
1. Página começa → open = false → sidebar não aparece.
2. Clicamos no botão hambúrguer → setOpen(true) → agora open = true.
3. O React re-renderiza → a condição {open && (...)} passa a ser verdadeira → sidebar aparece.
4. Dentro da sidebar, clicamos no X ou em algum link → setOpen(false).
5. React re-renderiza → open = false → sidebar some. 🎉



6️⃣ Tailwind na prática:

. Responsividade:
  . hidden md:flex → mostra só no desktop.
  . md:hidden → mostra só no celular.

. Layout da sidebar:
  . flex flex-col → organiza os links em coluna.
  . gap-6 → espaço entre os itens.

. Estilização do fundo:
  . bg-black/90 → cor preta transparente.
  . fixed top-0 left-0 → cobre a tela inteira (como um overlay).

✅ Resumo Final
. Criamos um estado (open) para controlar se o menu lateral está aberto ou fechado.
. No desktop → mostramos os links direto.
. No mobile → mostramos um botão hambúrguer que abre a sidebar.
. O React usa a lógica {open && (...)} para decidir se renderiza ou não a sidebar.
. O Tailwind nos ajudou com responsividade, espaçamentos e fundo fixo.

















🧠 Aula Completa: Validação de Formulário no React — Explicada Passo a Passo:

toda essa explicação é baseada na solução usada nesta aula.

🎯 Objetivo da aula:
Aprender a criar um formulário funcional com validação personalizada 
no React, sem precisar de bibliotecas externas, entendendo a lógica por trás de cada passo.

Essa aula foi feita para compreender o raciocínio da validação, e não apenas copiar código.


🧩 1. O que é validação de formulário:
A validação de formulário serve para verificar se os dados 
digitados pelo usuário estão corretos e completos antes de enviar o formulário.

Exemplo:
. Nome não pode ficar vazio;
. E-mail precisa conter “@” e “.”;
. A mensagem não pode estar em branco.

Sem validação, o usuário pode enviar o formulário com campos vazios ou errados, 
e isso pode gerar problemas depois (erros, mensagens sem contato, etc).



⚙️ 2. Criando os estados:

No React, usamos useState para guardar informações que mudam.
No caso de formulários, temos dois tipos de dados pra guardar:

. Os valores dos campos (nome, e-mail, mensagem);
. As mensagens de erro que aparecem caso algo esteja errado.

const [nome, setNome] = useState("");
const [email, setEmail] = useState("");
const [mensagem, setMensagem] = useState("");

// Estados para armazenar os erros
const [erroNome, setErroNome] = useState("");
const [erroEmail, setErroEmail] = useState("");
const [erroMensagem, setErroMensagem] = useState("");


📘 Por que usar estados?
Porque o React precisa “reagir” quando algo muda.
Ou seja, quando o usuário digita, o estado atualiza o valor automaticamente, e quando há um erro, o estado exibe a mensagem na tela.



🧠 3. Entendendo o funcionamento da função de validação:

Quando o usuário clicar no botão Enviar, uma função será executada para checar se os campos estão corretos.
Essa função será chamada, por exemplo, validarFormulario.


🔸 Variável de controle (temErro):
No início da função, criamos uma variável que vai controlar se há algum erro no formulário:

let temErro = false;


Se nenhum erro for encontrado, essa variável continua sendo false, e o formulário é enviado.
Mas se qualquer campo tiver erro, ela muda para true, e o envio é interrompido.

💡 Por que usar essa variável em vez de return direto?
Porque o return para a função imediatamente, e só permitiria validar um campo por vez.
Usando a variável temErro, conseguimos verificar todos os campos e marcar os erros 
de uma vez só, mesmo que existam vários.

No final, usamos uma condição pra impedir o envio caso algum erro tenha ocorrido:
js:
if (temErro) return; // se tiver erro, a função encerra aqui



🧽 4. Limpando mensagens antigas:

Antes de começar a validar, é importante limpar os erros anteriores, 
senão as mensagens antigas podem continuar aparecendo mesmo que o usuário já 
tenha corrigido os campos.
js:
setErroNome("");
setErroEmail("");
setErroMensagem("");


📘 Explicação mais profunda:
Mesmo que o usuário digite tudo certo na segunda tentativa, os estados de erro 
continuam guardando as mensagens da tentativa anterior.
Por isso, é fundamental limpá-los no início da função — pra garantir que a validação comece sempre “do zero”.



✅ 5. Validando os campos um por um:

Agora vamos criar as verificações (as condições if) para cada campo.

🧍‍♂️ Campo “Nome”
if (nome.trim() === "") {
  setErroNome("Por favor, digite seu nome.");
  temErro = true;
}


📘 Explicação detalhada:
. nome.trim() remove espaços antes e depois do texto (por exemplo, se o usuário digitar só “ ”);
. === "" verifica se o campo está realmente vazio;
. Se estiver, mostramos a mensagem de erro e marcamos que houve erro com temErro = true.

Traduzindo:
“Se o nome estiver em branco, mostre a mensagem e marque que há erro.”


📧 Campo “Email”:
if (!email.includes("@") || !email.includes(".")) {
  setErroEmail("Digite um email válido.");
  temErro = true;
}


🔍 Entendendo o includes():
O método .includes() verifica se um texto contém um certo caractere ou palavra.

Ele retorna:
. true se encontrar;
. false se não encontrar.

Exemplo rápido:
"banana".includes("b") // true
"banana".includes("z") // false


No nosso caso:
. email.includes("@") → verifica se o e-mail contém o símbolo “@”;
. email.includes(".") → verifica se contém um ponto “.” (parte final do domínio).

⚙️ O papel do ! (negação):
O ! inverte o valor.

Ou seja:
. Se email.includes("@") for true, o ! transforma em false;
. Se for false, o ! transforma em true.

Por isso, !email.includes("@") significa “se NÃO existir @”.

⚙️ O papel do || (ou):

O operador || significa “ou” — ele só precisa de uma condição verdadeira pra entrar no if.
Mas aqui estamos usando condições negativas, então:

Se não tiver “@” OU não tiver “.”, já é considerado inválido.
       Isso garante que o email precisa ter os dois — o “@” e o “.” — para passar na validação.



💬 Campo “Mensagem”:
if (mensagem.trim() === "") {
  setErroMensagem("Digite uma mensagem antes de enviar.");
  temErro = true;
}


📘 Explicação completa:

Usamos .trim() para eliminar espaços e garantir que o campo realmente tenha texto;
. A condição === "" verifica se o campo está vazio;
. Se estiver, exibimos a mensagem de erro;
. E marcamos o erro com temErro = true pra impedir o envio.



⛔ 6. Bloqueando o envio se houver erros:

Depois de validar todos os campos, verificamos se a variável de controle temErro virou true.

if (temErro) {
  return; // interrompe a função e impede o envio
}


🧠 Por que isso é importante?
Porque com essa verificação, conseguimos validar todos os campos de 
uma só vez, mostrar todas as mensagens de erro, e só enviar o formulário se estiver tudo certo.


📤 7. Enviando o formulário manualmente:
Por padrão, os formulários HTML enviam os dados automaticamente, 
mas no React, usamos eventos controlados.

Por isso, usamos:
js:
evento.preventDefault();


👉 Isso impede o envio automático.

E, no final, se tudo estiver certo, enviamos manualmente com:
js:
evento.target.submit();


📘 Entendendo linha por linha:
. evento → é o objeto que contém todas as informações da ação (neste caso, 
o clique no botão ou o envio do formulário);
. evento.target → representa o próprio formulário que foi enviado;
. .submit() → envia o formulário de forma manual, como se fosse o envio 
automático do HTML.

Usamos essa forma manual pra garantir que só envie se a validação estiver 100% certa.



💻 8. Exemplo completo:
import React, { useState } from "react";

export default function Formulario() {
  const [nome, setNome] = useState("");
  const [email, setEmail] = useState("");
  const [mensagem, setMensagem] = useState("");

  const [erroNome, setErroNome] = useState("");
  const [erroEmail, setErroEmail] = useState("");
  const [erroMensagem, setErroMensagem] = useState("");

  function validarFormulario(evento) {
    evento.preventDefault();

    // Limpando mensagens antigas
    setErroNome("");
    setErroEmail("");
    setErroMensagem("");

    let temErro = false; // variável de controle

    // Validação do nome
    if (nome.trim() === "") {
      setErroNome("Por favor, digite seu nome.");
      temErro = true;
    }

    // Validação do email
    if (!email.includes("@") || !email.includes(".")) {
      setErroEmail("Digite um email válido.");
      temErro = true;
    }

    // Validação da mensagem
    if (mensagem.trim() === "") {
      setErroMensagem("Digite uma mensagem antes de enviar.");
      temErro = true;
    }

    // Se tiver algum erro, para aqui
    if (temErro) return;

    // Se tudo estiver certo, envia o formulário
    evento.target.submit();
  }

  return (
    <form onSubmit={validarFormulario}>
      <input
        type="text"
        placeholder="Nome"
        value={nome}
        onChange={(e) => setNome(e.target.value)}
      />
      {erroNome && <p>{erroNome}</p>}

      <input
        type="email"
        placeholder="Email"
        value={email}
        onChange={(e) => setEmail(e.target.value)}
      />
      {erroEmail && <p>{erroEmail}</p>}

      <textarea
        placeholder="Mensagem"
        value={mensagem}
        onChange={(e) => setMensagem(e.target.value)}
      />
      {erroMensagem && <p>{erroMensagem}</p>}

      <button type="submit">Enviar</button>
    </form>
  );
}

🧾 9. O que você aprendeu

✅ Como usar estados para campos e mensagens de erro
✅ O que é a variável de controle e por que ela é essencial
✅ Por que limpar os erros no início da função
✅ Como funcionam includes(), ! e ||
✅ A diferença entre usar return e uma variável de controle
✅ Como impedir o envio automático e enviar manualmente com evento.target.submit()

💬 Conclusão

Agora você domina a base completa da validação manual no React — 
entendendo a lógica por trás, não só o código.
Na próxima vez que precisar validar qualquer formulário, é só olhar 
essas anotações e adaptar as condições conforme o caso.

-->