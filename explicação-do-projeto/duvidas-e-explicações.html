<!--



ğŸ“š Aula Explicada Passo a Passo: Navbar + Menu HambÃºrguer em React + TailwindCSS
ğŸ¯ O que vamos aprender
1. Como criar uma barra de navegaÃ§Ã£o (navbar) em React.
2. O que Ã© o menu hambÃºrguer e como ele funciona em telas pequenas.
3. Como usar o estado (useState) para abrir e fechar a sidebar.
4. Como o TailwindCSS nos ajuda com classes prontas para layout e responsividade.



1ï¸âƒ£ Estrutura da Navbar
Pensa assim:
. A navbar Ã© um retÃ¢ngulo fixo no topo da pÃ¡gina, com:
  . O logo ou nome Ã  esquerda.
  . Os links no meio ou Ã  direita.
  . O botÃ£o hambÃºrguer que aparece sÃ³ no celular.

ğŸ‘‰ Em React, cada pedaÃ§o da tela Ã© um componente. EntÃ£o criamos um componente chamado Navbar.

import React, { useState } from "react"

export default function Navbar() {
  const [open, setOpen] = useState(false) // estado para controlar se o menu estÃ¡ aberto ou fechado

  return (
    <nav className="fixed w-full flex items-center justify-between px-6 py-4 bg-black/80 text-white z-40">
      <h1 className="text-2xl font-bold">
        <span className="text-sky-300">Mikael</span> Rocha
      </h1>
    </nav>
  )
}

 
ğŸ” Aqui temos:
. useState(false) â†’ comeÃ§a fechado (false).
. nav â†’ a barra de navegaÃ§Ã£o.
. fixed w-full â†’ fixa no topo e ocupa a largura da tela inteira.
. px-6 py-4 â†’ espaÃ§amento interno.
. bg-black/80 â†’ fundo preto com transparÃªncia.

 


2ï¸âƒ£ Links da navbar:

Agora colocamos os links de navegaÃ§Ã£o.
Queremos que eles sÃ³ apareÃ§am em telas maiores (computador).
No Tailwind, fazemos isso com hidden md:flex.

<ul className="hidden md:flex gap-8 text-lg">
  <li><a href="#sobre">Sobre</a></li>
  <li><a href="#projeto">Projetos</a></li>
  <li><a href="#skills">Skills</a></li>
  <li><a href="#contato">Contato</a></li>
</ul>


ğŸ” Aqui:
. hidden â†’ por padrÃ£o fica invisÃ­vel.
. md:flex â†’ a partir do tamanho md (tablet para cima) vira flex e aparece.
. gap-8 â†’ espaÃ§amento entre os itens.

3ï¸âƒ£ BotÃ£o HambÃºrguer

Esse Ã© o botÃ£o que aparece somente no celular.
Ele abre o menu lateral quando clicamos.

<button
  className="md:hidden text-3xl"
  onClick={() => setOpen(true)}
>
  <i className="bx bx-menu"></i>
</button>


ğŸ” Aqui:
. md:hidden â†’ o botÃ£o sÃ³ aparece em telas menores que md.
. text-3xl â†’ aumenta o tamanho do Ã­cone.
. onClick={() => setOpen(true)} â†’ quando clicamos, mudamos o estado open para true.
. i className="bx bx-menu" â†’ Ã­cone do hambÃºrguer (as 3 listrinhas).




4ï¸âƒ£ Sidebar (menu lateral no mobile):

Agora o truque principal: sÃ³ queremos mostrar a sidebar se open === true.
No React, usamos {open && (...)}.

{open && (
  <div className="fixed top-0 left-0 w-2/3 h-full bg-black/90 text-white flex flex-col p-6 z-50">
    {/* BotÃ£o fechar */}
    <button
      className="self-end text-3xl mb-6"
      onClick={() => setOpen(false)}
    >
      <i className="bx bx-x"></i>
    </button>

    {/* Links mobile */}
    <ul className="flex flex-col gap-6 text-lg">
      <li><a href="#sobre" onClick={() => setOpen(false)}>Sobre</a></li>
      <li><a href="#projeto" onClick={() => setOpen(false)}>Projetos</a></li>
      <li><a href="#skills" onClick={() => setOpen(false)}>Skills</a></li>
      <li><a href="#contato" onClick={() => setOpen(false)}>Contato</a></li>
    </ul>
  </div>
)}


ğŸ” Detalhes importantes:
. {open && (...)} â†’ significa â€œse open for true, renderiza issoâ€.
. fixed top-0 left-0 â†’ fixa a sidebar no canto superior esquerdo.
. w-2/3 h-full â†’ ocupa 2/3 da tela em largura e 100% da altura.
. bg-black/90 â†’ fundo preto semi-transparente.
. z-50 â†’ garante que aparece por cima de tudo.
. setOpen(false) â†’ fecha o menu quando clicamos no X ou em um link.



5ï¸âƒ£ Como tudo funciona junto (fluxo):
1. PÃ¡gina comeÃ§a â†’ open = false â†’ sidebar nÃ£o aparece.
2. Clicamos no botÃ£o hambÃºrguer â†’ setOpen(true) â†’ agora open = true.
3. O React re-renderiza â†’ a condiÃ§Ã£o {open && (...)} passa a ser verdadeira â†’ sidebar aparece.
4. Dentro da sidebar, clicamos no X ou em algum link â†’ setOpen(false).
5. React re-renderiza â†’ open = false â†’ sidebar some. ğŸ‰



6ï¸âƒ£ Tailwind na prÃ¡tica:

. Responsividade:
  . hidden md:flex â†’ mostra sÃ³ no desktop.
  . md:hidden â†’ mostra sÃ³ no celular.

. Layout da sidebar:
  . flex flex-col â†’ organiza os links em coluna.
  . gap-6 â†’ espaÃ§o entre os itens.

. EstilizaÃ§Ã£o do fundo:
  . bg-black/90 â†’ cor preta transparente.
  . fixed top-0 left-0 â†’ cobre a tela inteira (como um overlay).

âœ… Resumo Final
. Criamos um estado (open) para controlar se o menu lateral estÃ¡ aberto ou fechado.
. No desktop â†’ mostramos os links direto.
. No mobile â†’ mostramos um botÃ£o hambÃºrguer que abre a sidebar.
. O React usa a lÃ³gica {open && (...)} para decidir se renderiza ou nÃ£o a sidebar.
. O Tailwind nos ajudou com responsividade, espaÃ§amentos e fundo fixo.

















ğŸ§  Aula Completa: ValidaÃ§Ã£o de FormulÃ¡rio no React â€” Explicada Passo a Passo:

toda essa explicaÃ§Ã£o Ã© baseada na soluÃ§Ã£o usada nesta aula.

ğŸ¯ Objetivo da aula:
Aprender a criar um formulÃ¡rio funcional com validaÃ§Ã£o personalizada 
no React, sem precisar de bibliotecas externas, entendendo a lÃ³gica por trÃ¡s de cada passo.

Essa aula foi feita para compreender o raciocÃ­nio da validaÃ§Ã£o, e nÃ£o apenas copiar cÃ³digo.


ğŸ§© 1. O que Ã© validaÃ§Ã£o de formulÃ¡rio:
A validaÃ§Ã£o de formulÃ¡rio serve para verificar se os dados 
digitados pelo usuÃ¡rio estÃ£o corretos e completos antes de enviar o formulÃ¡rio.

Exemplo:
. Nome nÃ£o pode ficar vazio;
. E-mail precisa conter â€œ@â€ e â€œ.â€;
. A mensagem nÃ£o pode estar em branco.

Sem validaÃ§Ã£o, o usuÃ¡rio pode enviar o formulÃ¡rio com campos vazios ou errados, 
e isso pode gerar problemas depois (erros, mensagens sem contato, etc).



âš™ï¸ 2. Criando os estados:

No React, usamos useState para guardar informaÃ§Ãµes que mudam.
No caso de formulÃ¡rios, temos dois tipos de dados pra guardar:

. Os valores dos campos (nome, e-mail, mensagem);
. As mensagens de erro que aparecem caso algo esteja errado.

const [nome, setNome] = useState("");
const [email, setEmail] = useState("");
const [mensagem, setMensagem] = useState("");

// Estados para armazenar os erros
const [erroNome, setErroNome] = useState("");
const [erroEmail, setErroEmail] = useState("");
const [erroMensagem, setErroMensagem] = useState("");


ğŸ“˜ Por que usar estados?
Porque o React precisa â€œreagirâ€ quando algo muda.
Ou seja, quando o usuÃ¡rio digita, o estado atualiza o valor automaticamente, e quando hÃ¡ um erro, o estado exibe a mensagem na tela.



ğŸ§  3. Entendendo o funcionamento da funÃ§Ã£o de validaÃ§Ã£o:

Quando o usuÃ¡rio clicar no botÃ£o Enviar, uma funÃ§Ã£o serÃ¡ executada para checar se os campos estÃ£o corretos.
Essa funÃ§Ã£o serÃ¡ chamada, por exemplo, validarFormulario.


ğŸ”¸ VariÃ¡vel de controle (temErro):
No inÃ­cio da funÃ§Ã£o, criamos uma variÃ¡vel que vai controlar se hÃ¡ algum erro no formulÃ¡rio:

let temErro = false;


Se nenhum erro for encontrado, essa variÃ¡vel continua sendo false, e o formulÃ¡rio Ã© enviado.
Mas se qualquer campo tiver erro, ela muda para true, e o envio Ã© interrompido.

ğŸ’¡ Por que usar essa variÃ¡vel em vez de return direto?
Porque o return para a funÃ§Ã£o imediatamente, e sÃ³ permitiria validar um campo por vez.
Usando a variÃ¡vel temErro, conseguimos verificar todos os campos e marcar os erros 
de uma vez sÃ³, mesmo que existam vÃ¡rios.

No final, usamos uma condiÃ§Ã£o pra impedir o envio caso algum erro tenha ocorrido:
js:
if (temErro) return; // se tiver erro, a funÃ§Ã£o encerra aqui



ğŸ§½ 4. Limpando mensagens antigas:

Antes de comeÃ§ar a validar, Ã© importante limpar os erros anteriores, 
senÃ£o as mensagens antigas podem continuar aparecendo mesmo que o usuÃ¡rio jÃ¡ 
tenha corrigido os campos.
js:
setErroNome("");
setErroEmail("");
setErroMensagem("");


ğŸ“˜ ExplicaÃ§Ã£o mais profunda:
Mesmo que o usuÃ¡rio digite tudo certo na segunda tentativa, os estados de erro 
continuam guardando as mensagens da tentativa anterior.
Por isso, Ã© fundamental limpÃ¡-los no inÃ­cio da funÃ§Ã£o â€” pra garantir que a validaÃ§Ã£o comece sempre â€œdo zeroâ€.



âœ… 5. Validando os campos um por um:

Agora vamos criar as verificaÃ§Ãµes (as condiÃ§Ãµes if) para cada campo.

ğŸ§â€â™‚ï¸ Campo â€œNomeâ€
if (nome.trim() === "") {
  setErroNome("Por favor, digite seu nome.");
  temErro = true;
}


ğŸ“˜ ExplicaÃ§Ã£o detalhada:
. nome.trim() remove espaÃ§os antes e depois do texto (por exemplo, se o usuÃ¡rio digitar sÃ³ â€œ â€);
. === "" verifica se o campo estÃ¡ realmente vazio;
. Se estiver, mostramos a mensagem de erro e marcamos que houve erro com temErro = true.

Traduzindo:
â€œSe o nome estiver em branco, mostre a mensagem e marque que hÃ¡ erro.â€


ğŸ“§ Campo â€œEmailâ€:
if (!email.includes("@") || !email.includes(".")) {
  setErroEmail("Digite um email vÃ¡lido.");
  temErro = true;
}


ğŸ” Entendendo o includes():
O mÃ©todo .includes() verifica se um texto contÃ©m um certo caractere ou palavra.

Ele retorna:
. true se encontrar;
. false se nÃ£o encontrar.

Exemplo rÃ¡pido:
"banana".includes("b") // true
"banana".includes("z") // false


No nosso caso:
. email.includes("@") â†’ verifica se o e-mail contÃ©m o sÃ­mbolo â€œ@â€;
. email.includes(".") â†’ verifica se contÃ©m um ponto â€œ.â€ (parte final do domÃ­nio).

âš™ï¸ O papel do ! (negaÃ§Ã£o):
O ! inverte o valor.

Ou seja:
. Se email.includes("@") for true, o ! transforma em false;
. Se for false, o ! transforma em true.

Por isso, !email.includes("@") significa â€œse NÃƒO existir @â€.

âš™ï¸ O papel do || (ou):

O operador || significa â€œouâ€ â€” ele sÃ³ precisa de uma condiÃ§Ã£o verdadeira pra entrar no if.
Mas aqui estamos usando condiÃ§Ãµes negativas, entÃ£o:

Se nÃ£o tiver â€œ@â€ OU nÃ£o tiver â€œ.â€, jÃ¡ Ã© considerado invÃ¡lido.
       Isso garante que o email precisa ter os dois â€” o â€œ@â€ e o â€œ.â€ â€” para passar na validaÃ§Ã£o.



ğŸ’¬ Campo â€œMensagemâ€:
if (mensagem.trim() === "") {
  setErroMensagem("Digite uma mensagem antes de enviar.");
  temErro = true;
}


ğŸ“˜ ExplicaÃ§Ã£o completa:

Usamos .trim() para eliminar espaÃ§os e garantir que o campo realmente tenha texto;
. A condiÃ§Ã£o === "" verifica se o campo estÃ¡ vazio;
. Se estiver, exibimos a mensagem de erro;
. E marcamos o erro com temErro = true pra impedir o envio.



â›” 6. Bloqueando o envio se houver erros:

Depois de validar todos os campos, verificamos se a variÃ¡vel de controle temErro virou true.

if (temErro) {
  return; // interrompe a funÃ§Ã£o e impede o envio
}


ğŸ§  Por que isso Ã© importante?
Porque com essa verificaÃ§Ã£o, conseguimos validar todos os campos de 
uma sÃ³ vez, mostrar todas as mensagens de erro, e sÃ³ enviar o formulÃ¡rio se estiver tudo certo.


ğŸ“¤ 7. Enviando o formulÃ¡rio manualmente:
Por padrÃ£o, os formulÃ¡rios HTML enviam os dados automaticamente, 
mas no React, usamos eventos controlados.

Por isso, usamos:
js:
evento.preventDefault();


ğŸ‘‰ Isso impede o envio automÃ¡tico.

E, no final, se tudo estiver certo, enviamos manualmente com:
js:
evento.target.submit();


ğŸ“˜ Entendendo linha por linha:
. evento â†’ Ã© o objeto que contÃ©m todas as informaÃ§Ãµes da aÃ§Ã£o (neste caso, 
o clique no botÃ£o ou o envio do formulÃ¡rio);
. evento.target â†’ representa o prÃ³prio formulÃ¡rio que foi enviado;
. .submit() â†’ envia o formulÃ¡rio de forma manual, como se fosse o envio 
automÃ¡tico do HTML.

Usamos essa forma manual pra garantir que sÃ³ envie se a validaÃ§Ã£o estiver 100% certa.



ğŸ’» 8. Exemplo completo:
import React, { useState } from "react";

export default function Formulario() {
  const [nome, setNome] = useState("");
  const [email, setEmail] = useState("");
  const [mensagem, setMensagem] = useState("");

  const [erroNome, setErroNome] = useState("");
  const [erroEmail, setErroEmail] = useState("");
  const [erroMensagem, setErroMensagem] = useState("");

  function validarFormulario(evento) {
    evento.preventDefault();

    // Limpando mensagens antigas
    setErroNome("");
    setErroEmail("");
    setErroMensagem("");

    let temErro = false; // variÃ¡vel de controle

    // ValidaÃ§Ã£o do nome
    if (nome.trim() === "") {
      setErroNome("Por favor, digite seu nome.");
      temErro = true;
    }

    // ValidaÃ§Ã£o do email
    if (!email.includes("@") || !email.includes(".")) {
      setErroEmail("Digite um email vÃ¡lido.");
      temErro = true;
    }

    // ValidaÃ§Ã£o da mensagem
    if (mensagem.trim() === "") {
      setErroMensagem("Digite uma mensagem antes de enviar.");
      temErro = true;
    }

    // Se tiver algum erro, para aqui
    if (temErro) return;

    // Se tudo estiver certo, envia o formulÃ¡rio
    evento.target.submit();
  }

  return (
    <form onSubmit={validarFormulario}>
      <input
        type="text"
        placeholder="Nome"
        value={nome}
        onChange={(e) => setNome(e.target.value)}
      />
      {erroNome && <p>{erroNome}</p>}

      <input
        type="email"
        placeholder="Email"
        value={email}
        onChange={(e) => setEmail(e.target.value)}
      />
      {erroEmail && <p>{erroEmail}</p>}

      <textarea
        placeholder="Mensagem"
        value={mensagem}
        onChange={(e) => setMensagem(e.target.value)}
      />
      {erroMensagem && <p>{erroMensagem}</p>}

      <button type="submit">Enviar</button>
    </form>
  );
}

ğŸ§¾ 9. O que vocÃª aprendeu

âœ… Como usar estados para campos e mensagens de erro
âœ… O que Ã© a variÃ¡vel de controle e por que ela Ã© essencial
âœ… Por que limpar os erros no inÃ­cio da funÃ§Ã£o
âœ… Como funcionam includes(), ! e ||
âœ… A diferenÃ§a entre usar return e uma variÃ¡vel de controle
âœ… Como impedir o envio automÃ¡tico e enviar manualmente com evento.target.submit()

ğŸ’¬ ConclusÃ£o

Agora vocÃª domina a base completa da validaÃ§Ã£o manual no React â€” 
entendendo a lÃ³gica por trÃ¡s, nÃ£o sÃ³ o cÃ³digo.
Na prÃ³xima vez que precisar validar qualquer formulÃ¡rio, Ã© sÃ³ olhar 
essas anotaÃ§Ãµes e adaptar as condiÃ§Ãµes conforme o caso.

-->